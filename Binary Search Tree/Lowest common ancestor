Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

Example 1:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Example 2:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
Example 3:

Input: root = [2,1], p = 2, q = 1
Output: 2


simple tree solution

class Solution {
public:

    TreeNode *helper(TreeNode *root,TreeNode *p,TreeNode *q){
        if (root==NULL || root==p || root==q){
            return root;
        }
        TreeNode *left=helper(root->left,p,q);
        TreeNode *right=helper(root->right,p,q);
        if (left==NULL){
            return right;
        }
        if (right==NULL){
            return left;
        }
        return root;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return helper(root,p,q);
    }
};


Binary search tree solution

class Solution {
public:

    TreeNode *helper(TreeNode *root,TreeNode *p,TreeNode *q){
        if (root==NULL){
            return NULL;
        }
        if (root->val>p->val && root->val>q->val){
            return helper(root->left,p,q);
        }
        else if (root->val<p->val && root->val<q->val){
            return helper(root->right,p,q);
        }
        return root;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return helper(root,p,q);
    }
};
