There is an integer array ‘A’ of size ‘N’.



Number of inversions in an array can be defined as the number of pairs of ‘i’, ‘j’ such that ‘i’ < ‘j’ and ‘A[i]’ > ‘A[j]’.

You must return the number of inversions in the array.



For example,

Explain
Input:
A = [5, 3, 2, 1, 4], N = 5
Output:
7
Explanation: 
The pairs satisfying the condition for inversion are (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), and (3, 4). 
The number of inversions in the array is 7.

#include <bits/stdc++.h>

int merge(vector<int> &a,int low,int mid,int high){
    int i=low,j=mid+1;
    vector<int> temp;
    int count=0;
    while (i<=mid && j<=high){
        if (a[i]<=a[j]){
            temp.push_back(a[i]);
            i++;
        }
        else{
            temp.push_back(a[j]);
            j++;
            count+=(mid-i+1);
        }
    }
    while (i<=mid){
        temp.push_back(a[i]);
        i++;
    }
    while (j<=high){
        temp.push_back(a[j]);
        j++;
    }
    for (int i=low;i<=high;i++){
        a[i]=temp[i-low];
    }
    return count;
}

int merge_sort(vector<int> &a,int low,int high){
    int count=0;
    if (low>=high){
        return count;
    }
    int mid=(low+high)/2;
    count+=merge_sort(a,low,mid);
    count+=merge_sort(a,mid+1,high);
    count+=merge(a,low,mid,high);
    return count;
}

int numberOfInversions(vector<int>&a, int n) {
    return merge_sort(a,0,n-1);
}
