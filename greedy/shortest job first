You have to implement the shortest job first scheduling algorithm.



Shortest Job First is an algorithm in which the process having the smallest execution(burst) time is chosen for the next execution. Here, you will implement a non - preemptive version (a process will wait till process(es) with shorter burst time executes). You have to return the average waiting for the given number of processes.



Completion Time: Time at which process completes its execution.


Example:

SJF will schedule the job which is having least burst time.

Hence, Average waiting time = (5 + 0 + 2) / 3 = 2.33

Detailed explanation ( Input/output format, Notes, Images )
Sample Input 1 :
3
0 3
0 1
0 2
Sample Output 1 :
1.33


float sjf(int n, vector<int> &arrivalTime, vector<int> &burstTime) 
{
    vector<pair<int,int>> v;
    for (int i=0;i<n;i++){
        v.push_back({arrivalTime[i],burstTime[i]});
    }
    sort(v.begin(),v.end());
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
    q.push({v[0].second,v[0].first});
    int time=v[0].first;
    int i=1;
    int wait=0;
    while (!q.empty()){
        auto x=q.top();
        q.pop();
        int arr=x.second;
        int bur=x.first;
        time+=bur;
        // waiting time is usko total kitna time lagta means arrival+burst but usko lga total completion time, so waiting time is total_completion time-(arrival+burst)
        wait+=(time-(arr+bur));
        while (true){
            if (i<n &&  v[i].first<=time){
                q.push({v[i].second,v[i].first});
                i++;
            }
            else{
                break;
            }
        }
    }
    return (float)wait/n;
}
