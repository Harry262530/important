Problem statement
You are given an array of ‘N’ distinct integers and an integer ‘X’ representing the target sum. You have to tell the minimum number of elements you have to take to reach the target sum ‘X’.

Note:
You have an infinite number of elements of each type.
For example
If N=3 and X=7 and array elements are [1,2,3]. 
Way 1 - You can take 4 elements  [2, 2, 2, 1] as 2 + 2 + 2 + 1 = 7.
Way 2 - You can take 3 elements  [3, 3, 1] as 3 + 3 + 1 = 7.
Here, you can see in Way 2 we have used 3 coins to reach the target sum of 7.
Hence the output is 3.

Sample Input 1 :
2
3 7
1 2 3
1 0
1
Sample output 1 :
 3
 0

 #include <bits/stdc++.h> 
int helper(int n,int coin,vector<vector<int>> &dp,vector<int> &arr){
    if (n==0){
        if (coin%arr[n]==0){
            return coin/arr[n];
        }
        // if you have to compare baad me then use 1e9+7
        return 1e9+7;
    }
    if (dp[n][coin]!=-1){
        return dp[n][coin];
    }
    int pick=INT_MAX;
    int notpick=helper(n-1,coin,dp,arr);
    if (coin>=arr[n]){
        // here we are adding 1 because other questions me ham pure path ke hone ke baad add krte the but yha hamko sath me count leke chlna hai
        pick=1+helper(n,coin-arr[n],dp,arr);
    }
    return dp[n][coin]=min(pick,notpick);
}
int minimumElements(vector<int> &num, int x)
{
    int n=num.size();
    vector<vector<int>> dp(n,vector<int>(x+1,-1));
    int ans= helper(n-1,x,dp,num);
    if (ans>=1e9+7){
        return -1;
    }
    return ans;
}
