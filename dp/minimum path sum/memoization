Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

 

Example 1:


Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12

class Solution {
public:
    int helper(int n,int m,vector<vector<int>> &dp,vector<vector<int>> &grid){
        if (n==0 && m==0){
            return grid[n][m];
        }
        if (dp[n][m]!=-1){
            return dp[n][m];
        }
        int down=INT_MAX,right=INT_MAX;
        if (n>0){
            down=grid[n][m]+helper(n-1,m,dp,grid);
        }
        if (m>0){
            right=grid[n][m]+helper(n,m-1,dp,grid);
        }
        return dp[n][m]=min(down,right);
    }
    
    int minPathSum(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));
        return helper(n-1,m-1,dp,grid);
    }
};
