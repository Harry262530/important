You are given an array of binary strings strs and two integers m and n.

Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.

A set x is a subset of a set y if all elements of x are also elements of y.

 

Example 1:

Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.


class Solution {
public:
int t[601][101][101];
    int helper(int ind,int one,int zero,vector<string> &strs,int n,int m){
        if (one>n || zero>m || ind>=strs.size()){
            return 0;
        }
        if (t[ind][one][zero]!=-1){
            return t[ind][one][zero];
        }
        int o=0,z=0;
        for (int i=0;i<strs[ind].size();i++){
            if (strs[ind][i]=='1'){
                o++;
            }
            else{
                z++;
            }
        }
        int pick=0;
        if (one+o<=n && zero+z<=m){
            pick=1+helper(ind+1,one+o,zero+z,strs,n,m);
        }
        int notpick=helper(ind+1,one,zero,strs,n,m);
        return t[ind][one][zero]=max(pick,notpick);
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        memset(t,-1,sizeof(t));
        return helper(0,0,0,strs,n,m);
    }
};
